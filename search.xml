<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mergesort]]></title>
    <url>%2F2017%2F09%2F02%2FMergesort%2F</url>
    <content type="text"><![CDATA[归并排序归并排序（Merge sort）是创建在归并操作上的一种有效的排序算法，效率为O(n log n)。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。 归并操作（merge）也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。 迭代法 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列 设定两个指针，最初位置分别为两个已经排序序列的起始位置 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 重复步骤3直到某一指针到达序列尾 将另一序列剩下的所有元素直接复制到合并序列尾 递归法 原理如下（假设序列共有n个元素）： 将序列每相邻两个数字进行归并操作，形成 floor(n/2)个序列，排序后每个序列包含两个元素 将上述序列再次归并，形成 floor(n/4)个序列，每个序列包含四个元素 重复步骤2，直到所有元素排序完毕 具体实现（自顶而下的递归+迭代）1234567891011121314151617void merge_sort(int *A, int x, int y, int *T) &#123; if (y - x &gt; 1) &#123; int m = x + (y - x) / 2; //划分 int p = x, q = m, i = x; merge_sort(A, x, m, T); //递归求解 merge_sort(A, m, y, T); //递归求解 while (p &lt; m || q &lt; y) &#123; if (q &gt;= y || (p &lt; m &amp;&amp; A[p] &lt;= A[q])) T[i++] = A[p++]; //从左半数组复制到临时空间 else &#123; T[i++] = A[q++]; //从右半数组复制到临时空间 &#125; &#125; for (i = x; i &lt; y; i++) A[i] = T[i]; //从辅助空间复制回A数组 &#125;&#125; 利用归并排序解决逆序对问题 给一列数a1,a2,…,an，求它的逆序对数，即有多少个有序对(i,j）,iaj。n可以高达106。 划分问题：将原序列分解成尽可能长度相等的两个子序列 递归过程：统计左子序列和右子序列的逆序对 合并问题：统计左右子序列合并后的逆序对每当左右子序列合并的时候，可以发现如果右子序列的元素i放入临时容器中，那么左子序列中当前元素j到末尾的元素全部都是大于i的，由此就可以得到cnt+=m-p这样的一个表达式。 C++实现 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int maxn = 1000000;int A[maxn], T[maxn];int merge_sort(int *A, int x, int y, int *T);int cnt=0;int main() &#123; int n; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;A[i]); &#125; merge_sort(A, 0, n, T); std::cout &lt;&lt; "逆序对:" &lt;&lt; cnt &lt;&lt; std::endl; for (int i = 0; i &lt; n; i++) &#123; printf("%d ", A[i]); //排序后 &#125; return 0;&#125;int merge_sort(int *A, int x, int y, int *T) &#123; if (y - x &gt; 1) &#123; int m = x + (y - x) / 2; //划分 int p = x, q = m, i = x; merge_sort(A, x, m, T); //递归求解 merge_sort(A, m, y, T); //递归求解 while (p &lt; m || q &lt; y) &#123; if (q &gt;= y || (p &lt; m &amp;&amp; A[p] &lt;= A[q])) T[i++] = A[p++]; //从左半数组复制到临时空间 else &#123; T[i++] = A[q++]; //从右半数组复制到临时空间 cnt+=m-p; //计算逆序数 &#125; &#125; for (i = x; i &lt; y; i++) A[i] = T[i]; //从辅助空间复制回A数组 &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quicksort]]></title>
    <url>%2F2017%2F09%2F02%2FQuicksort%2F</url>
    <content type="text"><![CDATA[快排基本思想设当前待排序的无序区为 R[low..high]，利用分治法可将快速排序的基本思想描述为： 1.分解：在 R[low..high]中任选一个记录作为基准(Pivot)，以此基准将当前无序区划分为左、右两个较小的子区间 R[low..pivotpos-1)和 R[pivotpos+1..high]，并使左边子区间中所有记录的关键字均小于等于基准记录(不妨记为 pivot)的关键字 pivot.key，右边的子区间中所有记录的关键字均大于等于 pivot.key，而基准记录 pivot 则位于正确的位置(pivotpos)上，它无须参加后续的排序。 注意： 划分的关键是要求出基准记录所在的位置 pivotpos。划分的结果可以简单地表示为(注意 pivot=R[pivotpos])： R[low..pivotpos-1].keys≤R[pivotpos].key≤R[pivotpos+1..high].keys 其中 low≤pivotpos≤high。 2.求解：通过递归调用快速排序对左、右子区间 R[low..pivotpos-1]和R[pivotpos+1..high]快速排序。 3.组合：因为当”求解”步骤中的两个递归调用结束时，其左、右两个子区间已有序。对快速排序而言，”组合”步骤无须做什么，可看作是空操作。 快速排序算法 QuickSort 123456789void QuickSort(SeqList R，int low，int high) &#123; //对R[low..high]快速排序 int pivotpos; //划分后的基准记录的位置 if(low&lt;high)&#123; //仅当区间长度大于1时才须排序 pivotpos=Partition(R，low，high); //对R[low..high]做划分 QuickSort(R，low，pivotpos-1); //对左区间递归排序 QuickSort(R，pivotpos+1，high); //对右区间递归排序 &#125; &#125; //QuickSort 划分算法 Partition简单的划分方法 1. 具体做法 (初始化)设置两个指针 i 和 j，它们的初值分别为区间的下界和上界，即 i=low，i=high；选取无序区的第一个记录 Ri作为基准记录，并将它保存在变量 pivot 中； 令 j 自 high 起向左扫描，直到找到第 1 个关键字小于 pivot.key 的记录 R[j]，将 R[j])移至 i 所指的位置上，这相当于 R[j] 和基准 Ri进行了交换，使关键字小于基准关键字 pivot.key 的记录移到了基准的左边，交换后 R[j]中相当于是 pivot；然后，令 i 指针自 i+1 位置开始向右扫描，直至找到第 1 个关键字大于 pivot.key 的记录 R[i]，将 R[i]移到 i 所指的位置上，这相当于交换了 R[i] 和基准 R[j]，使关键字大于基准关键字的记录移到了基准的右边，交换后 R[i] 中又相当于存放了 pivot；接着令指针 j 自位置 j-1 开始向左扫描，如此交替改变扫描方向，从两端各自往中间靠拢，直至 i=j 时，i便是基准 pivot 最终的位置，将 pivot 放在此位置上就完成了一次划分。 2. 划分算法1234567891011121314151617int Partition(SeqList R，int i，int j) &#123; //调用Partition(R，low，high)时，对R[low..high]做划分， //并返回基准记录的位置 ReceType pivot=R[i]； //用区间的第1个记录作为基准 ' while(i&lt;j)&#123; //从区间两端交替向中间扫描，直至i=j为止 while(i&lt;j&amp;&amp;R[j].key&gt;=pivot.key) //pivot相当于在位置i上 j--； //从右向左扫描，查找第1个关键字小于pivot.key的记录R[j] if(i&lt;j) //表示找到的R[j]的关键字&lt;pivot.key R[i++]=R[j]； //相当于交换R[i]和R[j]，交换后i指针加1 while(i&lt;j&amp;&amp;R[i].key&lt;=pivot.key) //pivot相当于在位置j上 i++； //从左向右扫描，查找第1个关键字大于pivot.key的记录R[i] if(i&lt;j) //表示找到了R[i]，使R[i].key&gt;pivot.key R[j--]=R[i]; //相当于交换R[i]和R[j]，交换后j指针减1 &#125; //endwhile R[i]=pivot； //基准记录已被最后定位 return i； &#125; //partition 快速选择问题输入n个整数和一个正整数K(1&lt;=K&lt;=n)，输出这些整数从小到大排序后的第K个。n&lt;=107【分析】选择第K大的数，最容易想到的方法是先排序，然后直接输出下标是K-1的元素，但107的规模即使对于O(nlogn)的算法来说也较大。假设在快速排序的“划分”结束后，数组A[p……r]被分成了A[p……q]和A[q+1……r]，则可以根据左边的元素个数q-p+1和k的大小关系只在左边或只在右边递归求解。所以只在原快速排序的基础上增加if……else语句即可。可以证明，在期望意义下，程序的时间复杂度为O（n）。 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;using namespace std;void QuickSort(int R[], int low, int high,int k);int Partition(int R[], int i, int j);int main() &#123; int n, k; scanf("%d%d", &amp;n, &amp;k); int R[n]; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;R[i]); &#125; QuickSort(R, 0, n - 1,k); for (int i = 0; i &lt; n; i++) &#123; printf("%d ", R[i]); &#125; printf("\n"); printf("%d", R[k-1]); return 0;&#125;void QuickSort(int R[], int low, int high,int k) &#123; int pivotpos; if (low &lt; high) &#123; pivotpos = Partition(R, low, high); if(k&lt;pivotpos) QuickSort(R, low, pivotpos - 1,k); else QuickSort(R, pivotpos + 1, high,k); &#125;&#125;int Partition(int R[], int i, int j) &#123; int pivot = R[i]; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; R[j] &gt;= pivot) j--; if (i &lt; j) R[i++] = R[j]; while (i &lt; j &amp;&amp; R[i] &lt;= pivot) i++; if (i &lt; j) R[j--] = R[i]; &#125; R[i] = pivot; return i;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
</search>
