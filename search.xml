<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[insertSort]]></title>
    <url>%2F2018%2F02%2F13%2FInsertSort%2F</url>
    <content type="text"><![CDATA[插入排序插入排序是基于比较的排序。所谓的基于比较，就是通过比较数组中的元素，看谁大谁小，根据结果来调整元素的位置。因此，对于这类排序，就有两种基本的操作：①比较操作； ②交换操作 1.直接插入排序 基本思想：将一个记录插入到已排序好的有序表中，从而得到一个新的记录数增1的有序表 要点：设立哨兵作为临时存储和判断数组边界之用 稳定性：如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。 12345678910for(int i=1;i&lt;arr.length;i++)&#123; if(arr[i]&lt;arr[i-1])&#123; //[0...i-1]都已排序好 int temp=arr[i]; int j; for(j=i;j&gt;0&amp;&amp;arr[j]&gt;temp;j--)&#123; //注意边界 arr[j+1]=arr[j]; &#125; arr[j]=temp; &#125;&#125; 12345678910111213for(int j=2;j&lt;arr.length;j++)&#123; do&#123; int key=arr[j]; i=j-1; while(i&gt;0&amp;&amp;arr[i]&gt;key)&#123; do&#123; arr[i+1]=arr[i]; i=i-1; &#125; &#125; A[i+1]=key; &#125;&#125; 123456789101112131415void InsertSort(int a[], int n)&#123; for(int i= 1; i&lt;n; i++)&#123; if(a[i] &lt; a[i-1])&#123;//若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入 int j= i-1; int x = a[i]; //复制为哨兵，即存储待排序元素 a[i] = a[i-1]; //先后移一个元素 while(x &lt; a[j])&#123; //查找在有序表的插入位置 a[j+1] = a[j]; j--; //元素后移 &#125; a[j+1] = x; //插入到正确位置 &#125; &#125;&#125; 希尔排序 思想：先将要排序的一组记录按某个增量d（n/2,n为要排序数的个数）分成若干组子序列，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。继续不断缩小增量直至为1，最后使用直接插入排序完成排序。 不稳定：希尔排序时效分析很难，关键码的比较次数与记录移动次数依赖于增量因子序列d的选取，特定情况下可以准确估算出关键码的比较次数和记录的移动次数。目前还没有人给出选取最好的增量因子序列的方法。增量因子序列可以有各种取法，有取奇数的，也有取质数的，但需要注意：增量因子中除1 外没有公因子，且最后一个增量因子必须为1。希尔排序方法是一个不稳定的排序方法。12345678910111213141516171819202122232425262728293031/** * 直接插入排序的一般形式 * * @param int dk 缩小增量，如果是直接插入排序，dk=1 * */ void ShellInsertSort(int a[],int n,int dk)&#123; for(int i=dk;i&lt;n;++i)&#123; if(a[i]&lt;a[i-dk])&#123; int j=i-dk; int x=a[i]; a[i]=a[i-dk]; while(x&lt;a[j])&#123; a[j+dk]=a[j]; j-=dk; &#125; a[j+dk]=x; &#125; &#125;&#125;/** * 先按增量d（n/2,n为要排序数的个数进行希尔排序 * */ void shellSort(int a[],int n)&#123; int dk=n/2; while(dk&gt;=1)&#123; ShellInsertSort(a,n,dk); dk=dk/2; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux与windows双系统]]></title>
    <url>%2F2017%2F09%2F07%2FLinux%E4%B8%8Ewindows%E5%8F%8C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[虚拟机（Virtual Machine）指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。虚拟系统通过生成现有操作系统的全新虚拟镜像，它具有真实windows系统完全一样的功能，进入虚拟系统后，所有操作都是在这个全新的独立的虚拟系统里面进行，可以独立安装运行软件，保存数据，拥有自己的独立桌面，不会对真正的系统产生任何影响 ，而且具有能够在现有系统与虚拟镜像之间灵活切换的一类操作系统。虚拟系统和传统的虚拟机（Parallels Desktop ，Vmware，VirtualBox，Virtual pc）不同在于：虚拟系统不会降低电脑的性能，启动虚拟系统不需要像启动windows系统那样耗费时间，运行程序更加方便快捷；虚拟系统只能模拟和现有操作系统相同的环境，而虚拟机则可以模拟出其他种类的操作系统；而且虚拟机需要模拟底层的硬件指令，所以在应用程序运行速度上比虚拟系统慢得多。流行的虚拟机软件有VMware(VMWare ACE）、Virtual Box和Virtual PC，它们都能在Windows系统上虚拟出多个计算机。VMware（中文名威睿”） 虚拟机软件使用Vmware，你可以同时运行Linux各种发行版、Dos、Windows各种版本，Unix等，你甚至可以在同一台计算机上安装多个Linux发行版、 多个Windows版本。VMware可以使你在一台机器上同时运行二个或更多Windows、DOS、LINUX系统。与“多启动”系统相比，VMWare采用了完全不同的概念。多启动系统在一个时刻只能运行一个系统，在系统切换时需要重新启动机器。VMWare是真正“同时”运行，多个操作系统在主系统的平台上，就象标准Windows应用程序那样切换。而且每个操作系统你都可以进行虚拟的分区、配置而不影响真实硬盘的数据，你甚至可以通过网卡将几台虚拟机用网卡连接为一个局域网，极其方便。安装在VMware操作系统性能上比直接安装在硬盘上的系统低不少，因此，比较适合学习和测试。 VMware Workstation允许操作系统(OS)和应用程序(Application)在一台虚拟机内部运行。虚拟机是独立运行主机操作系统的离散环境。在 VMware Workstation 中，你可以在一个窗口中加载一台虚拟机，它可以运行自己的操作系统和应用程序。你可以在运行于桌面上的多台虚拟机之间切换，通过一个网络共享虚拟机(例如一个公司局域网)，挂起和恢复虚拟机以及退出虚拟机，这一切不会影响你的主机操作和任何操作系统或者其它正在运行的应用程序。 WinSCP是一个Windows环境下使用SSH的开源图形化SFTP客户端。同时支持SCP协议。它的主要功能就是在本地与远程计算机间安全的复制文件。.winscp也可以链接其他系统,比如linux系统 下载VMware Workstation 12 Pro VMware Workstation 12序列号：5A02H-AU243-TZJ49-GTC7K-3C61N]]></content>
      <tags>
        <tag>linux</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MaxSubseqSum]]></title>
    <url>%2F2017%2F09%2F03%2FMaxSubseqSum%2F</url>
    <content type="text"><![CDATA[最大子列和问题 之前学习刘汝佳老师的《算法竞赛》，在CSDN上写了一篇相似的文章，现在在学习浙大陈越老师的数据结构，再次回顾和补充，如有不当之处还请批评指正！ 最大子列和问题 给出一个长度为n的序列A1,A2,……,An,要求找到1≤i≤j≤n,使得Ai+Ai+1+……+Aj尽量大。 算法1 : 枚举使用枚举，程序如下：123456789101112tot = 0; best = A[1]; //初始最大值 for (int i = 1; i &lt;= n; i++) for (int j = i; j &lt;= n; j++) &#123; //检查连续子序列A[i],……,A[j] int sum = 0; for (int k = i; k &lt;= j; k++) &#123; sum += A[k]; //累加元素和 tot++; &#125; if (sum &gt; best) best = sum; //更新最大值 &#125; 设输入规模为n时，加法操作的次数为T(n),则$$T(n)=\sum{i=1}^n \sum{j=i}^nj-i+1=\sum_{i=1}^n\frac{(n-i+1)(n-i+2)}{2}=\frac{n(n+1)(n+2)}{6}$$用一个记号来表示：T(n)=O(n $$$ ^3 $$$) 下面试着优化一下这个算法 算法2设S$ {i} $=A$ {1} $+A$ {2} $+……+A$ {i} $,则A$ {i} $+A$ {i+1} $+……+A$ {j} $=S ${j} $-S$ _{i-1} $，其直观含义是”连续子序列之和等于两个前缀和之差“。这样可以省略最内层的循环。 123456S[0] = 0; for (int i = 1; i &lt;= n; i++) S[i] = S[i - 1] + A[i]; //递推前缀和S for (int i = 1; i &lt;= n; i++) for (int j = i; j &lt;= n; j++) best = max(best, S[j] - S[i - 1]); //更新最大值 类似的方法可以分析出：$$T(n)=\sum_{i=1}^nn-i+1= \frac{n(n+1)}{2}$$时间复杂度是O(n$ ^2 $). 算法3：分治法分治算法一般分为以下三个步骤： 划分问题 ：把问题的实例划分为子问题； 递归求解 ：递归解决子问题； 合并问题 ：合并子问题的解得到原问题的解。在本例中，”划分“就是把序列尽量分成元素个数相等的两半；”递归求解“就是分别求出完全位于左半和完全位于右半的最佳序列；”合并“就是求出起点位于左半，终点位于右半的最大连续和序列，并和子问题的最优解比较。 12345678910111213141516int maxsum(int *A, int x, int y) &#123; //返回数组在左闭右开区间[x,y)中的最大连续和 int V, L, R, maxs; if (y - x == 1) return A[x]; int m = x + (y - x) / 2; //分治第一步：划分成[x,m)和[m,y) maxs = max(maxsum(A, x, m), maxsum(A, m, y)); //分治第二步：递归求解 V = 0; L = A[m - 1]; //分治第三步：合并（1）——从分界点开始往左的最大连续和L for (int i = m - 1; i &gt;= x; i--) L = max(L, V += A[i]); V = 0; R = A[m]; //分治第三步：合并（2）——从分界点开始往右的最大连续和R for (int i = m; i &lt;= y; i++) R = max(R, V += A[i]); return max(maxs, L + R); //把子问题的解与L + R比较&#125; 递归方程T(n)=2T(n/2)+O(n),T(1)=1,解为T(n)=O(n log n). 时间复杂度推导如图所示： 算法4：在线处理“在线”的意思是指每输入一个数据就进行即时处理，在任何一个地方中止输入，算法都能正确给出当前的解。向右累加，发现更大和则更新当前结果，如果当前子列和为负，抛弃之，将当前和置零。123456789101112131415int MaxSubseqSum4( int A[], int N )&#123; int ThisSum, MaxSum; int i; ThisSum = MaxSum = 0; for( i = 0; i &lt; N; i++ ) &#123; ThisSum += A[i]; /* 向右累加 */ if( ThisSum &gt; MaxSum ) MaxSum = ThisSum; /* 发现更大和则更新当前结果 */ else if( ThisSum &lt; 0 ) /* 如果当前子列和为负 */ ThisSum = 0; /* 则不可能使后面的部分和增大，抛弃之 */ &#125; return MaxSum;&#125; 很明显，只用到了一个for循环，算法复杂度T(n)=O(n). 算法分析结果 表-运算量随着规模的变化 运算量 最大规模 速度扩大两倍后 n! 11 11 2$^n$ 26 27 n$^3$ 464 584 n$^2$ 10000 14142 nlog$_{2}$n 4.5x10$^6$ 8.6x10$^6$ n 100000000 200000000 借鉴此表，在算法竞赛中，一个指明n$ \leq $8的题目可能n!的算法已经足够，n$ \leq $20的题目需要用到2$ ^n $ 的算法，而n$ \leq $300的题目可能必须用至少n$ ^3 $的多项式时间算法了。]]></content>
      <categories>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mergesort]]></title>
    <url>%2F2017%2F09%2F02%2FMergesort%2F</url>
    <content type="text"><![CDATA[归并排序归并排序（Merge sort）是创建在归并操作上的一种有效的排序算法，效率为O(n log n)。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。 归并操作（merge）也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。 迭代法 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列 设定两个指针，最初位置分别为两个已经排序序列的起始位置 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置 重复步骤3直到某一指针到达序列尾 将另一序列剩下的所有元素直接复制到合并序列尾 递归法 原理如下（假设序列共有n个元素）： 将序列每相邻两个数字进行归并操作，形成 floor(n/2)个序列，排序后每个序列包含两个元素 将上述序列再次归并，形成 floor(n/4)个序列，每个序列包含四个元素 重复步骤2，直到所有元素排序完毕 具体实现（自顶而下的递归+迭代）1234567891011121314151617void merge_sort(int *A, int x, int y, int *T) &#123; if (y - x &gt; 1) &#123; int m = x + (y - x) / 2; //划分 int p = x, q = m, i = x; merge_sort(A, x, m, T); //递归求解 merge_sort(A, m, y, T); //递归求解 while (p &lt; m || q &lt; y) &#123; if (q &gt;= y || (p &lt; m &amp;&amp; A[p] &lt;= A[q])) T[i++] = A[p++]; //从左半数组复制到临时空间 else &#123; T[i++] = A[q++]; //从右半数组复制到临时空间 &#125; &#125; for (i = x; i &lt; y; i++) A[i] = T[i]; //从辅助空间复制回A数组 &#125;&#125; 利用归并排序解决逆序对问题 给一列数a1,a2,…,an，求它的逆序对数，即有多少个有序对(i,j）,iaj。n可以高达106。 划分问题：将原序列分解成尽可能长度相等的两个子序列 递归过程：统计左子序列和右子序列的逆序对 合并问题：统计左右子序列合并后的逆序对每当左右子序列合并的时候，可以发现如果右子序列的元素i放入临时容器中，那么左子序列中当前元素j到末尾的元素全部都是大于i的，由此就可以得到cnt+=m-p这样的一个表达式。 C++实现 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;const int maxn = 1000000;int A[maxn], T[maxn];int merge_sort(int *A, int x, int y, int *T);int cnt=0;int main() &#123; int n; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;A[i]); &#125; merge_sort(A, 0, n, T); std::cout &lt;&lt; "逆序对:" &lt;&lt; cnt &lt;&lt; std::endl; for (int i = 0; i &lt; n; i++) &#123; printf("%d ", A[i]); //排序后 &#125; return 0;&#125;int merge_sort(int *A, int x, int y, int *T) &#123; if (y - x &gt; 1) &#123; int m = x + (y - x) / 2; //划分 int p = x, q = m, i = x; merge_sort(A, x, m, T); //递归求解 merge_sort(A, m, y, T); //递归求解 while (p &lt; m || q &lt; y) &#123; if (q &gt;= y || (p &lt; m &amp;&amp; A[p] &lt;= A[q])) T[i++] = A[p++]; //从左半数组复制到临时空间 else &#123; T[i++] = A[q++]; //从右半数组复制到临时空间 cnt+=m-p; //计算逆序数 &#125; &#125; for (i = x; i &lt; y; i++) A[i] = T[i]; //从辅助空间复制回A数组 &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quicksort]]></title>
    <url>%2F2017%2F09%2F02%2FQuicksort%2F</url>
    <content type="text"><![CDATA[快排基本思想设当前待排序的无序区为 R[low..high]，利用分治法可将快速排序的基本思想描述为： 1.分解：在 R[low..high]中任选一个记录作为基准(Pivot)，以此基准将当前无序区划分为左、右两个较小的子区间 R[low..pivotpos-1)和 R[pivotpos+1..high]，并使左边子区间中所有记录的关键字均小于等于基准记录(不妨记为 pivot)的关键字 pivot.key，右边的子区间中所有记录的关键字均大于等于 pivot.key，而基准记录 pivot 则位于正确的位置(pivotpos)上，它无须参加后续的排序。 注意： 划分的关键是要求出基准记录所在的位置 pivotpos。划分的结果可以简单地表示为(注意 pivot=R[pivotpos])： R[low..pivotpos-1].keys≤R[pivotpos].key≤R[pivotpos+1..high].keys 其中 low≤pivotpos≤high。 2.求解：通过递归调用快速排序对左、右子区间 R[low..pivotpos-1]和R[pivotpos+1..high]快速排序。 3.组合：因为当”求解”步骤中的两个递归调用结束时，其左、右两个子区间已有序。对快速排序而言，”组合”步骤无须做什么，可看作是空操作。 快速排序算法 QuickSort 123456789void QuickSort(SeqList R，int low，int high) &#123; //对R[low..high]快速排序 int pivotpos; //划分后的基准记录的位置 if(low&lt;high)&#123; //仅当区间长度大于1时才须排序 pivotpos=Partition(R，low，high); //对R[low..high]做划分 QuickSort(R，low，pivotpos-1); //对左区间递归排序 QuickSort(R，pivotpos+1，high); //对右区间递归排序 &#125; &#125; //QuickSort 划分算法 Partition简单的划分方法 1. 具体做法 (初始化)设置两个指针 i 和 j，它们的初值分别为区间的下界和上界，即 i=low，i=high；选取无序区的第一个记录 Ri作为基准记录，并将它保存在变量 pivot 中； 令 j 自 high 起向左扫描，直到找到第 1 个关键字小于 pivot.key 的记录 R[j]，将 R[j])移至 i 所指的位置上，这相当于 R[j] 和基准 Ri进行了交换，使关键字小于基准关键字 pivot.key 的记录移到了基准的左边，交换后 R[j]中相当于是 pivot；然后，令 i 指针自 i+1 位置开始向右扫描，直至找到第 1 个关键字大于 pivot.key 的记录 R[i]，将 R[i]移到 i 所指的位置上，这相当于交换了 R[i] 和基准 R[j]，使关键字大于基准关键字的记录移到了基准的右边，交换后 R[i] 中又相当于存放了 pivot；接着令指针 j 自位置 j-1 开始向左扫描，如此交替改变扫描方向，从两端各自往中间靠拢，直至 i=j 时，i便是基准 pivot 最终的位置，将 pivot 放在此位置上就完成了一次划分。 2. 划分算法1234567891011121314151617int Partition(SeqList R，int i，int j) &#123; //调用Partition(R，low，high)时，对R[low..high]做划分， //并返回基准记录的位置 ReceType pivot=R[i]； //用区间的第1个记录作为基准 ' while(i&lt;j)&#123; //从区间两端交替向中间扫描，直至i=j为止 while(i&lt;j&amp;&amp;R[j].key&gt;=pivot.key) //pivot相当于在位置i上 j--； //从右向左扫描，查找第1个关键字小于pivot.key的记录R[j] if(i&lt;j) //表示找到的R[j]的关键字&lt;pivot.key R[i++]=R[j]； //相当于交换R[i]和R[j]，交换后i指针加1 while(i&lt;j&amp;&amp;R[i].key&lt;=pivot.key) //pivot相当于在位置j上 i++； //从左向右扫描，查找第1个关键字大于pivot.key的记录R[i] if(i&lt;j) //表示找到了R[i]，使R[i].key&gt;pivot.key R[j--]=R[i]; //相当于交换R[i]和R[j]，交换后j指针减1 &#125; //endwhile R[i]=pivot； //基准记录已被最后定位 return i； &#125; //partition 快速选择问题输入n个整数和一个正整数K(1&lt;=K&lt;=n)，输出这些整数从小到大排序后的第K个。n&lt;=107【分析】选择第K大的数，最容易想到的方法是先排序，然后直接输出下标是K-1的元素，但107的规模即使对于O(nlogn)的算法来说也较大。假设在快速排序的“划分”结束后，数组A[p……r]被分成了A[p……q]和A[q+1……r]，则可以根据左边的元素个数q-p+1和k的大小关系只在左边或只在右边递归求解。所以只在原快速排序的基础上增加if……else语句即可。可以证明，在期望意义下，程序的时间复杂度为O（n）。 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;using namespace std;void QuickSort(int R[], int low, int high,int k);int Partition(int R[], int i, int j);int main() &#123; int n, k; scanf("%d%d", &amp;n, &amp;k); int R[n]; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;R[i]); &#125; QuickSort(R, 0, n - 1,k); for (int i = 0; i &lt; n; i++) &#123; printf("%d ", R[i]); &#125; printf("\n"); printf("%d", R[k-1]); return 0;&#125;void QuickSort(int R[], int low, int high,int k) &#123; int pivotpos; if (low &lt; high) &#123; pivotpos = Partition(R, low, high); if(k&lt;pivotpos) QuickSort(R, low, pivotpos - 1,k); else QuickSort(R, pivotpos + 1, high,k); &#125;&#125;int Partition(int R[], int i, int j) &#123; int pivot = R[i]; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; R[j] &gt;= pivot) j--; if (i &lt; j) R[i++] = R[j]; while (i &lt; j &amp;&amp; R[i] &lt;= pivot) i++; if (i &lt; j) R[j--] = R[i]; &#125; R[i] = pivot; return i;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
</search>
